!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AbsCosTheta	bsdf.hpp	/^static inline double AbsCosTheta(const Vector &wi)$/;"	f	namespace:Swan
BSDF	bsdf.hpp	/^		BSDF(const Spectrum &r):r_(r) { }$/;"	f	class:Swan::BSDF
BSDF	bsdf.hpp	/^class BSDF$/;"	c	namespace:Swan
Bsdf	isect.hpp	/^		const BSDF* Bsdf() const { return bsdf_; }$/;"	f	class:Swan::Isect
CosTheta	bsdf.hpp	/^static inline double CosTheta(const Vector &wi)$/;"	f	namespace:Swan
CosineWeightedHemisphere	bsdf.hpp	/^static inline Vector CosineWeightedHemisphere()$/;"	f	namespace:Swan
Cross	vector.hpp	/^inline Vector3<T> Cross(const Vector3<T> &lhs, const Vector3<T> &rhs)$/;"	f	namespace:Swan
DiffuseBSDF	bsdf.hpp	/^		DiffuseBSDF(const Spectrum &r):BSDF(r) { }$/;"	f	class:Swan::DiffuseBSDF
DiffuseBSDF	bsdf.hpp	/^class DiffuseBSDF : public BSDF$/;"	c	namespace:Swan
Direction	ray.hpp	/^		const Vector& Direction() const { return direction_; }$/;"	f	class:Swan::Ray
DirectionalLight	light.hpp	/^		DirectionalLight(const Vector &direction, const Spectrum &intensity)$/;"	f	class:Swan::DirectionalLight
DirectionalLight	light.hpp	/^class DirectionalLight : public Light$/;"	c	namespace:Swan
Distance	isect.hpp	/^		double Distance() const { return distance_; }$/;"	f	class:Swan::Isect
Dot	vector.hpp	/^inline T Dot(const Vector3<T> &lhs, const Vector3<T> &rhs)$/;"	f	namespace:Swan
E	constant.hpp	/^const double E         = 2.718281828459045;$/;"	m	namespace:Swan
FindDouble	parameter.hpp	/^		double FindDouble() {$/;"	f	class:Swan::Parameter
FindInteger	parameter.hpp	/^		int FindInteger() {$/;"	f	class:Swan::Parameter
FindLight	parser.hpp	/^		Light* FindLight() {$/;"	f	class:Swan::Parser
FindObject	parser.hpp	/^		Object* FindObject() {$/;"	f	class:Swan::Parser
FindPosition	parameter.hpp	/^		Point FindPosition() {$/;"	f	class:Swan::Parameter
FindString	parameter.hpp	/^		std::string FindString() {$/;"	f	class:Swan::Parameter
FindVector	parameter.hpp	/^		Vector FindVector() {$/;"	f	class:Swan::Parameter
FresnelDielectric	bsdf.hpp	/^double FresnelDielectric(double cosi, double etai, double etat)$/;"	f	namespace:Swan
GetScene	parser.hpp	/^		Scene GetScene() const {$/;"	f	class:Swan::Parser
INV_PI	constant.hpp	/^const double INV_PI    = 1.0 \/ PI;$/;"	m	namespace:Swan
Integrator	integrator.hpp	/^		Integrator(int samples, const Scene &scene)$/;"	f	class:Swan::Integrator
Integrator	integrator.hpp	/^class Integrator$/;"	c	namespace:Swan
Intersect	scene.hpp	/^		bool Intersect(const Ray &ray, Isect &isect) const {$/;"	f	class:Swan::Scene
IntersectP	scene.hpp	/^		bool IntersectP(const Ray &ray, double distance) const {$/;"	f	class:Swan::Scene
IsDelta	bsdf.hpp	/^		virtual bool IsDelta() const { return false; }$/;"	f	class:Swan::BSDF
Isect	isect.hpp	/^		Isect():distance_(kInfinity) { }$/;"	f	class:Swan::Isect
Isect	isect.hpp	/^class Isect$/;"	c	namespace:Swan
Length	vector.hpp	/^		double Length () const { return std::sqrt(Length2()); }$/;"	f	class:Swan::Vector3
Length2	vector.hpp	/^		double Length2() const { return x_ * x_ + y_ * y_ + z_ * z_; }$/;"	f	class:Swan::Vector3
Light	light.hpp	/^		Light() { }$/;"	f	class:Swan::Light
Light	light.hpp	/^class Light$/;"	c	namespace:Swan
Lights	scene.hpp	/^		const std::vector<Light *>& Lights() const { return lights_; }$/;"	f	class:Swan::Scene
Miss	isect.hpp	/^		double Miss() const { return distance_ == kInfinity; }$/;"	f	class:Swan::Isect
NewDiffuseBSDF	bsdf.hpp	/^BSDF* NewDiffuseBSDF(Parameter &param)$/;"	f	namespace:Swan
NewDirectionalLight	light.hpp	/^Light* NewDirectionalLight(Parameter &param)$/;"	f	namespace:Swan
NewPlane	object.hpp	/^Object* NewPlane(Parameter &param, const BSDF *bsdf)$/;"	f	namespace:Swan
NewPointLight	light.hpp	/^Light* NewPointLight(Parameter &param)$/;"	f	namespace:Swan
NewReflectBSDF	bsdf.hpp	/^BSDF* NewReflectBSDF(Parameter &param)$/;"	f	namespace:Swan
NewSphere	object.hpp	/^Object* NewSphere(Parameter &param, const BSDF *bsdf)$/;"	f	namespace:Swan
Normal	isect.hpp	/^		Vector Normal() const { return normal_; }$/;"	f	class:Swan::Isect
Normalize	vector.hpp	/^inline Vector3<T> Normalize(const Vector3<T> &v)$/;"	f	namespace:Swan
Object	object.hpp	/^		Object(const BSDF *bsdf):bsdf_(bsdf) { }$/;"	f	class:Swan::Object
Object	object.hpp	/^class Object$/;"	c	namespace:Swan
Objects	scene.hpp	/^		const std::vector<Object *>& Objects() const { return objects_; }$/;"	f	class:Swan::Scene
Origin	ray.hpp	/^		const Point& Origin() const { return origin_; }$/;"	f	class:Swan::Ray
PI	constant.hpp	/^const double PI        = 3.141592653589793238;$/;"	m	namespace:Swan
Parameter	parameter.hpp	/^		Parameter() { }$/;"	f	class:Swan::Parameter
Parameter	parameter.hpp	/^		Parameter(const std::string &str, int line):str_(std::istringstream(str)), line_(line) { }$/;"	f	class:Swan::Parameter
Parameter	parameter.hpp	/^class Parameter$/;"	c	namespace:Swan
Parser	parser.hpp	/^		Parser(const char *file):line_(1) {$/;"	f	class:Swan::Parser
Parser	parser.hpp	/^class Parser$/;"	c	namespace:Swan
PathTracer	path_tracer.hpp	/^		PathTracer(int samples, const Scene &scene, int max_depth)$/;"	f	class:Swan::PathTracer
PathTracer	path_tracer.hpp	/^class PathTracer : public Integrator$/;"	c	namespace:Swan
Plane	object.hpp	/^		Plane(const Point &position, const Vector &normal, const BSDF *bsdf)$/;"	f	class:Swan::Plane
Plane	object.hpp	/^class Plane : public Object$/;"	c	namespace:Swan
Point	point.hpp	/^typedef Point3<double> Point;$/;"	t	namespace:Swan
Point2	point.hpp	/^		Point2():x_(0), y_(0) { }$/;"	f	class:Swan::Point2
Point2	point.hpp	/^		Point2(const Point2<T> &p):x_(p.x_), y_(p.y_) { }$/;"	f	class:Swan::Point2
Point2	point.hpp	/^		Point2(const T &x, const T &y):x_(x), y_(y) { }$/;"	f	class:Swan::Point2
Point2	point.hpp	/^		explicit Point2(const T &t):x_(t), y_(t) { }$/;"	f	class:Swan::Point2
Point2	point.hpp	/^class Point2$/;"	c	namespace:Swan
Point3	point.hpp	/^		Point3():x_(0), y_(0), z_(0) { }$/;"	f	class:Swan::Point3
Point3	point.hpp	/^		Point3(const Point3<T> &p):x_(p.x_), y_(p.y_), z_(p.z_) { }$/;"	f	class:Swan::Point3
Point3	point.hpp	/^		Point3(const T &t):x_(t), y_(t), z_(t) { }$/;"	f	class:Swan::Point3
Point3	point.hpp	/^		Point3(const T &x, const T &y, const T &z):x_(x), y_(y), z_(z) { }$/;"	f	class:Swan::Point3
Point3	point.hpp	/^		Point3(const Vector3<U> &v):x_(v.x_), y_(v.y_), z_(v.z_) { }$/;"	f	class:Swan::Point3
Point3	point.hpp	/^class Point3$/;"	c	namespace:Swan
PointLight	light.hpp	/^		PointLight(const Point &position, const Spectrum &intensity)$/;"	f	class:Swan::PointLight
PointLight	light.hpp	/^class PointLight : public Light$/;"	c	namespace:Swan
Position	isect.hpp	/^		Point Position() const { return position_; }$/;"	f	class:Swan::Isect
Position	point.hpp	/^typedef Point3<double> Position;$/;"	t	namespace:Swan
Ray	ray.hpp	/^		Ray(const Point &origin, const Vector &direction):origin_(origin), direction_(direction) { }$/;"	f	class:Swan::Ray
Ray	ray.hpp	/^class Ray$/;"	c	namespace:Swan
ReflectBSDF	bsdf.hpp	/^		ReflectBSDF(const Spectrum &r):BSDF(r) { }$/;"	f	class:Swan::ReflectBSDF
ReflectBSDF	bsdf.hpp	/^class ReflectBSDF : public BSDF$/;"	c	namespace:Swan
RefractBSDF	bsdf.hpp	/^		RefractBSDF(const Spectrum &r, double etai, double etat)$/;"	f	class:Swan::RefractBSDF
RefractBSDF	bsdf.hpp	/^class RefractBSDF : public BSDF$/;"	c	namespace:Swan
Render	integrator.hpp	/^		std::string Render() {$/;"	f	class:Swan::Integrator
SampleLe	light.hpp	/^		Spectrum SampleLe(Vector &wi, const Point2<double> &u,$/;"	f	class:Swan::DirectionalLight
SampleLe	light.hpp	/^		Spectrum SampleLe(Vector &wi, const Point2<double> &u,$/;"	f	class:Swan::PointLight
SampleLi	light.hpp	/^		Spectrum SampleLi(const Point &position, Vector &wi, double &dis, double &pdf) const {$/;"	f	class:Swan::DirectionalLight
SampleLi	light.hpp	/^		Spectrum SampleLi(const Point &position, Vector &wi, double &dis, double &pdf) const {$/;"	f	class:Swan::PointLight
Scene	scene.hpp	/^		Scene() { }$/;"	f	class:Swan::Scene
Scene	scene.hpp	/^		Scene(const std::vector<Object *> &objects, const std::vector<Light *> &lights)$/;"	f	class:Swan::Scene
Scene	scene.hpp	/^class Scene$/;"	c	namespace:Swan
Spectrum	vector.hpp	/^typedef Vector3<double> Spectrum;$/;"	t	namespace:Swan
Sphere	object.hpp	/^		Sphere(double radius, const Point &position, const BSDF *bsdf)$/;"	f	class:Swan::Sphere
Sphere	object.hpp	/^class Sphere : public Object$/;"	c	namespace:Swan
Swan	bsdf.hpp	/^namespace Swan {$/;"	n
Swan	constant.hpp	/^namespace Swan {$/;"	n
Swan	integrator.hpp	/^namespace Swan {$/;"	n
Swan	isect.hpp	/^namespace Swan {$/;"	n
Swan	light.hpp	/^namespace Swan {$/;"	n
Swan	object.hpp	/^namespace Swan {$/;"	n
Swan	parameter.hpp	/^namespace Swan {$/;"	n
Swan	parser.hpp	/^namespace Swan {$/;"	n
Swan	path_tracer.hpp	/^namespace Swan {$/;"	n
Swan	point.hpp	/^namespace Swan {$/;"	n
Swan	ray.hpp	/^namespace Swan {$/;"	n
Swan	scene.hpp	/^namespace Swan {$/;"	n
Swan	vector.hpp	/^namespace Swan {$/;"	n
UniformSphere	light.hpp	/^static inline Vector UniformSphere(const Point2<double> &u) {$/;"	f	namespace:Swan
Update	isect.hpp	/^		void Update(double distance,$/;"	f	class:Swan::Isect
Vector	vector.hpp	/^typedef Vector3<double> Vector;$/;"	t	namespace:Swan
Vector3	vector.hpp	/^		Vector3():x_(0), y_(0), z_(0) { }$/;"	f	class:Swan::Vector3
Vector3	vector.hpp	/^		Vector3(const T &x, const T &y, const T &z):x_(x), y_(y), z_(z) { }$/;"	f	class:Swan::Vector3
Vector3	vector.hpp	/^		Vector3(const Vector3<T> &v):x_(v.x_), y_(v.y_), z_(v.z_) { }$/;"	f	class:Swan::Vector3
Vector3	vector.hpp	/^		explicit Vector3(const T &t):x_(t), y_(t), z_(t) { }$/;"	f	class:Swan::Vector3
Vector3	vector.hpp	/^class Vector3$/;"	c	namespace:Swan
WriteImage	integrator.hpp	/^		std::string WriteImage() {$/;"	f	class:Swan::Integrator
_BSDF_HPP_	bsdf.hpp	9;"	d
_CONSTANT_HPP_	constant.hpp	9;"	d
_INTEGRATOR_HPP_	integrator.hpp	9;"	d
_ISECT_HPP_	isect.hpp	9;"	d
_LIGHT_HPP_	light.hpp	9;"	d
_OBJECT_HPP_	object.hpp	9;"	d
_PARAMETER_HPP_	parameter.hpp	9;"	d
_PARSER_HPP_	parser.hpp	9;"	d
_PATH_TRACER_HPP_	path_tracer.hpp	9;"	d
_POINT_HPP_	point.hpp	9;"	d
_RAY_HPP_	ray.hpp	9;"	d
_SCENE_HPP_	scene.hpp	9;"	d
_VECTOR_HPP_	vector.hpp	9;"	d
bsdf_	isect.hpp	/^		const BSDF *bsdf_;$/;"	m	class:Swan::Isect
bsdf_	object.hpp	/^		const BSDF *bsdf_;$/;"	m	class:Swan::Object
check	parameter.hpp	/^		void check() const {$/;"	f	class:Swan::Parameter
direction_	light.hpp	/^		const Vector   direction_;$/;"	m	class:Swan::DirectionalLight
direction_	ray.hpp	/^		Vector direction_;$/;"	m	class:Swan::Ray
distance_	isect.hpp	/^		double      distance_;$/;"	m	class:Swan::Isect
distribution_	integrator.hpp	/^		std::uniform_real_distribution<double> distribution_;$/;"	m	class:Swan::Integrator
etai_	bsdf.hpp	/^		double etai_;$/;"	m	class:Swan::RefractBSDF
etat_	bsdf.hpp	/^		double etat_;$/;"	m	class:Swan::RefractBSDF
generator_	integrator.hpp	/^		std::default_random_engine generator_;$/;"	m	class:Swan::Integrator
intensity_	light.hpp	/^		const Spectrum intensity_;$/;"	m	class:Swan::DirectionalLight
intensity_	light.hpp	/^		const Spectrum intensity_;$/;"	m	class:Swan::PointLight
kEpsilon	constant.hpp	/^const double kEpsilon  = 1e-4;$/;"	m	namespace:Swan
kInfinity	constant.hpp	/^const double kInfinity = std::numeric_limits<double>::max();$/;"	m	namespace:Swan
lights_	parser.hpp	/^		std::vector<Light *>  lights_;$/;"	m	class:Swan::Parser
lights_	scene.hpp	/^		const std::vector<Light *>  lights_;$/;"	m	class:Swan::Scene
line_	parameter.hpp	/^		int                line_;$/;"	m	class:Swan::Parameter
line_	parser.hpp	/^		int       line_;$/;"	m	class:Swan::Parser
main	swan.cpp	/^int main(int argc, char **argv)$/;"	f
max_depth_	path_tracer.hpp	/^		int max_depth_;$/;"	m	class:Swan::PathTracer
normal_	isect.hpp	/^		Vector      normal_;$/;"	m	class:Swan::Isect
normal_	object.hpp	/^		Vector normal_;$/;"	m	class:Swan::Plane
objects_	parser.hpp	/^		std::vector<Object *> objects_;$/;"	m	class:Swan::Parser
objects_	scene.hpp	/^		const std::vector<Object *> objects_;$/;"	m	class:Swan::Scene
operator !=	point.hpp	/^		bool operator!=(const Point2<T> &p) { return !operator==(p); }$/;"	f	class:Swan::Point2
operator !=	point.hpp	/^		bool operator!=(const Point3<T> &p) const { return !operator==(p); }$/;"	f	class:Swan::Point3
operator !=	vector.hpp	/^		bool operator!=(const Vector3<T> &v) const {return !operator==(v);}$/;"	f	class:Swan::Vector3
operator *	point.hpp	/^		Point2<T> operator*(const U u) const {$/;"	f	class:Swan::Point2
operator *	point.hpp	/^		Point3<T> operator*(const U u) const {$/;"	f	class:Swan::Point3
operator *	vector.hpp	/^		Vector3<T> operator*(const U u) const {$/;"	f	class:Swan::Vector3
operator *	vector.hpp	/^		Vector3<T> operator*(const Vector3<U> &u) const {$/;"	f	class:Swan::Vector3
operator *=	point.hpp	/^		Point2<T>& operator*=(const U u) {$/;"	f	class:Swan::Point2
operator *=	point.hpp	/^		Point3<T>& operator*=(const U u) {$/;"	f	class:Swan::Point3
operator *=	vector.hpp	/^		Vector3<T> operator*=(const Vector3<U> &u) {$/;"	f	class:Swan::Vector3
operator *=	vector.hpp	/^		Vector3<T>& operator*=(const U u) {$/;"	f	class:Swan::Vector3
operator +	point.hpp	/^		Point2<T> operator+(const Point2<T> &p) const {$/;"	f	class:Swan::Point2
operator +	point.hpp	/^		Point3<T> operator+(const Point3<T> &p) const {$/;"	f	class:Swan::Point3
operator +	point.hpp	/^		Point3<T> operator+(const Vector3<T> &v) const {$/;"	f	class:Swan::Point3
operator +	vector.hpp	/^		Vector3<T> operator+(const Vector3<T> &v) const {$/;"	f	class:Swan::Vector3
operator +=	point.hpp	/^		Point2<T>& operator+=(const Point2<T> &p) {$/;"	f	class:Swan::Point2
operator +=	point.hpp	/^		Point3<T>& operator+=(const Point3<T> &p) {$/;"	f	class:Swan::Point3
operator +=	point.hpp	/^		Point3<T>& operator+=(const Vector3<T> &v) {$/;"	f	class:Swan::Point3
operator +=	vector.hpp	/^		Vector3<T>& operator+=(const Vector3<T> &v) {$/;"	f	class:Swan::Vector3
operator -	point.hpp	/^		Point2<T> operator-() const { return Point2<T>(-x_, -y_); }$/;"	f	class:Swan::Point2
operator -	point.hpp	/^		Point2<T> operator-(const Point2<T> &p) const {$/;"	f	class:Swan::Point2
operator -	point.hpp	/^		Point3<T> operator-() const { return Point3<T>(-x_, -y_, -z_); }$/;"	f	class:Swan::Point3
operator -	point.hpp	/^		Point3<T> operator-(const Vector3<T> &v) const {$/;"	f	class:Swan::Point3
operator -	point.hpp	/^		Vector3<T> operator-(const Point3<T> &p) const {$/;"	f	class:Swan::Point3
operator -	vector.hpp	/^		Vector3<T> operator-() const { return Vector3<T>(-x_, -y_, -z_); }$/;"	f	class:Swan::Vector3
operator -	vector.hpp	/^		Vector3<T> operator-(const Vector3<T> &v) const {$/;"	f	class:Swan::Vector3
operator -=	point.hpp	/^		Point2<T>& operator-=(const Point2<T> &p) {$/;"	f	class:Swan::Point2
operator -=	point.hpp	/^		Point3<T>& operator-=(const Point3<T> &p) {$/;"	f	class:Swan::Point3
operator -=	point.hpp	/^		Point3<T>& operator-=(const Vector3<T> &v) {$/;"	f	class:Swan::Point3
operator -=	vector.hpp	/^		Vector3<T>& operator-=(const Vector3<T> &v) {$/;"	f	class:Swan::Vector3
operator /	point.hpp	/^		Point2<T> operator\/(const U u) const {$/;"	f	class:Swan::Point2
operator /	point.hpp	/^		Point3<T> operator\/(const U u) const {$/;"	f	class:Swan::Point3
operator /	vector.hpp	/^		Vector3<T> operator\/(const U u) const {$/;"	f	class:Swan::Vector3
operator /=	point.hpp	/^		Point2<T>& operator\/=(const U u) {$/;"	f	class:Swan::Point2
operator /=	point.hpp	/^		Point3<T>& operator\/=(const U u) {$/;"	f	class:Swan::Point3
operator /=	vector.hpp	/^		Vector3<T>& operator\/=(const U u) {$/;"	f	class:Swan::Vector3
operator <<	point.hpp	/^		friend std::ostream& operator<<(std::ostream &os, const Point2<T> &p) {$/;"	f	class:Swan::Point2
operator <<	point.hpp	/^		friend std::ostream& operator<<(std::ostream &os, const Point3<T> &p) {$/;"	f	class:Swan::Point3
operator <<	vector.hpp	/^		friend std::ostream& operator<<(std::ostream &os, const Vector3<T> &v) {$/;"	f	class:Swan::Vector3
operator =	point.hpp	/^		Point2<T>& operator=(const Point2<T> &p) {$/;"	f	class:Swan::Point2
operator =	point.hpp	/^		Point3& operator=(const Point3<T> &p) {$/;"	f	class:Swan::Point3
operator =	vector.hpp	/^		Vector3<T>& operator=(const Vector3<T> &v) {$/;"	f	class:Swan::Vector3
operator ==	point.hpp	/^		bool operator==(const Point2<T> &p) { return x_ == p.x_ && y_ == p.y_; }$/;"	f	class:Swan::Point2
operator ==	point.hpp	/^		bool operator==(const Point3<T> &p) const { return x_ == p.x_ && y_ == p.y_ && z_ == p.z_; }$/;"	f	class:Swan::Point3
operator ==	vector.hpp	/^		bool operator==(const Vector3<T> &v) const {return x_ == v.x_ && y_ == v.y_ && z_ == v.z_;}$/;"	f	class:Swan::Vector3
operator Vector3<U>	point.hpp	/^		explicit operator Vector3<U>() const {$/;"	f	class:Swan::Point3
operator []	point.hpp	/^		T& operator[](size_t i) {$/;"	f	class:Swan::Point2
operator []	point.hpp	/^		T& operator[](size_t i) {$/;"	f	class:Swan::Point3
operator []	point.hpp	/^		const T& operator[](size_t i) const {$/;"	f	class:Swan::Point2
operator []	point.hpp	/^		const T& operator[](size_t i) const {$/;"	f	class:Swan::Point3
operator []	vector.hpp	/^		T& operator[](size_t i) {$/;"	f	class:Swan::Vector3
operator []	vector.hpp	/^		const T& operator[](size_t i) const {$/;"	f	class:Swan::Vector3
origin_	ray.hpp	/^		Point  origin_;$/;"	m	class:Swan::Ray
parameter_	parser.hpp	/^		Parameter parameter_;$/;"	m	class:Swan::Parser
pixel_bound_	integrator.hpp	/^		const Point2<int> pixel_bound_;$/;"	m	class:Swan::Integrator
pixels_	integrator.hpp	/^		Vector           *pixels_;$/;"	m	class:Swan::Integrator
position_	isect.hpp	/^		Point       position_;$/;"	m	class:Swan::Isect
position_	light.hpp	/^		const Point    position_;$/;"	m	class:Swan::PointLight
position_	object.hpp	/^		Point  position_;$/;"	m	class:Swan::Plane
position_	object.hpp	/^		const Point  position_;$/;"	m	class:Swan::Sphere
r_	bsdf.hpp	/^		const Spectrum r_;$/;"	m	class:Swan::BSDF
radian	constant.hpp	/^inline double radian(double angle) {$/;"	f	namespace:Swan
radius_	object.hpp	/^		const double radius_;$/;"	m	class:Swan::Sphere
samples_	integrator.hpp	/^		const int         samples_;$/;"	m	class:Swan::Integrator
scene_	integrator.hpp	/^		const Scene       scene_;$/;"	m	class:Swan::Integrator
str_	parameter.hpp	/^		std::istringstream str_;$/;"	m	class:Swan::Parameter
x_	point.hpp	/^		T x_, y_, z_;$/;"	m	class:Swan::Point3
x_	point.hpp	/^		T x_;$/;"	m	class:Swan::Point2
x_	vector.hpp	/^		T x_, y_, z_;$/;"	m	class:Swan::Vector3
y_	point.hpp	/^		T x_, y_, z_;$/;"	m	class:Swan::Point3
y_	point.hpp	/^		T y_;$/;"	m	class:Swan::Point2
y_	vector.hpp	/^		T x_, y_, z_;$/;"	m	class:Swan::Vector3
z_	point.hpp	/^		T x_, y_, z_;$/;"	m	class:Swan::Point3
z_	vector.hpp	/^		T x_, y_, z_;$/;"	m	class:Swan::Vector3
~BSDF	bsdf.hpp	/^		virtual ~BSDF() { }$/;"	f	class:Swan::BSDF
~Integrator	integrator.hpp	/^		virtual ~Integrator() { delete [] pixels_; }$/;"	f	class:Swan::Integrator
~Light	light.hpp	/^		virtual ~Light() { }$/;"	f	class:Swan::Light
~Object	object.hpp	/^		virtual ~Object() { }$/;"	f	class:Swan::Object
~Parser	parser.hpp	/^		~Parser() {$/;"	f	class:Swan::Parser
